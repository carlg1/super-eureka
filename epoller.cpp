/////////////////////////////////////////////////////////////////////////////////
// #includes
/////////////////////////////////////////////////////////////////////////////////
#include <iostream>
#include <sstream>

#include <string.h>
#include <unistd.h>
#include <errno.h>

#include "epoller.h"


/////////////////////////////////////////////////////////////////////////////////
// #defines
/////////////////////////////////////////////////////////////////////////////////
#define MAXEVTCNT 20


/////////////////////////////////////////////////////////////////////////////////
// namespaces
/////////////////////////////////////////////////////////////////////////////////
using namespace std;


/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////
//
// Class Funtions
//
/////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// EPoller()
/////////////////////////////////////////////////////////////////////////////////
EPoller::EPoller(const int _timeout)
{
	rdyfds = -1;
	maxevtcnt = MAXEVTCNT;

	if(_timeout < -1 || _timeout > 10000)
		throw invalid_argument("_timeout must be between -1 and 10000");
	else
		timeout = _timeout;

	events = (struct epoll_event *) malloc(sizeof(struct epoll_event) * maxevtcnt);
	if(events == nullptr)
		throw runtime_error("Out of memory! Failed to malloc memory for event buffer!");

	if((epollfd = epoll_create1(EPOLL_CLOEXEC)) < 0)
	{
		typeof(errno) en = errno;
		ostringstream errmsg;

		errmsg << "Call to 'epoll_create1' failed due to '" << strerror(en) << "' [errno = " << en <<"]!";
		free(events);

		throw runtime_error(errmsg.str());
	}
}


/////////////////////////////////////////////////////////////////////////////////
// ~EPoller()
/////////////////////////////////////////////////////////////////////////////////
EPoller::~EPoller()
{
	if(epollfd != -1)
		Shutdown();

	free(events);
}


/////////////////////////////////////////////////////////////////////////////////
// Shutdown()
/////////////////////////////////////////////////////////////////////////////////
void EPoller::Shutdown()
{
	if(epollfd > -1)
		close(epollfd);
	epollfd = -1;
}


/////////////////////////////////////////////////////////////////////////////////
// AddFD()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::AddFD(const int fd, const int epoll_events, const epoller_cb_t *cb)
{
	return epollerctlfd(fd, epoll_events, cb, EPOLL_CTL_ADD);
}


/////////////////////////////////////////////////////////////////////////////////
// ModifyFD()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::ModifyFD(const int fd, const int epoll_events, const epoller_cb_t *cb)
{
	return epollerctlfd(fd, epoll_events, cb, EPOLL_CTL_MOD);
}


/////////////////////////////////////////////////////////////////////////////////
// RemoveFD()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::RemoveFD(const int fd)
{
	return epollerctlfd(fd, 0, nullptr, EPOLL_CTL_DEL);
}


/////////////////////////////////////////////////////////////////////////////////
// epollctlfd()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::epollerctlfd(const int fd, const int epoll_events, const epoller_cb_t *cb, const int op)
{
	struct epoll_event event;

	event.data.ptr = (void *) cb;
	event.events = epoll_events;

	if(epoll_ctl(epollfd, op, fd, &event) < 0)
	{
		typeof(errno) en = errno;
		cerr << "'epoll_ctl' failed [" << en << " <" << strerror(en) << ">]!" << endl;
		return false;
	}

	return true;
}


/////////////////////////////////////////////////////////////////////////////////
// Poll()
/////////////////////////////////////////////////////////////////////////////////
EPoller::epoller_rv EPoller::Poll()
{
	rdyfds = epoll_wait(epollfd, events, maxevtcnt, timeout);
	if(rdyfds < 0)
	{
		typeof(errno) en = errno;
		cerr << "'epoll_ctl' failed [" << en << " <" << strerror(en) << ">]!" << endl;
		return EPOLLER_ERR;
	}
	else if(rdyfds == 0)
		return EPOLLER_NODATA;
	else
		return EPOLLER_DATA;
}


/////////////////////////////////////////////////////////////////////////////////
// ProccessLoop()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::ProccessLoop()
{
	bool rv;

	if(rdyfds < 0)
		return false;

	for(int i = 0; i < rdyfds; i++)
	{
		rv = ((epoller_cb_t *) events[i].data.ptr)->funct(((epoller_cb_t *) events[i].data.ptr)->obj, events[i].events);
		if(rv == false)
			return false;
	}

	return true;
}
