/////////////////////////////////////////////////////////////////////////////////
// #includes
/////////////////////////////////////////////////////////////////////////////////
#include <iostream>

#include <string.h>
#include <unistd.h>
#include <sys/epoll.h>
#include <errno.h>

#include "epoller.h"


/////////////////////////////////////////////////////////////////////////////////
// #defines
/////////////////////////////////////////////////////////////////////////////////
#define MAXEVTCNT 20


/////////////////////////////////////////////////////////////////////////////////
// namespaces
/////////////////////////////////////////////////////////////////////////////////
using namespace std;


/////////////////////////////////////////////////////////////////////////////////
// Class Funtions
/////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////
// EPoller()
/////////////////////////////////////////////////////////////////////////////////
EPoller::EPoller(int to)
{
	rdyfds = -1;
	fdcnt = 0;
	timeout = -2; //fix me
	maxevtcnt = MAXEVTCNT;

	if((epollfd = epoll_create1(EPOLL_CLOEXEC)) < 0)
	{
		typeof(errno) en = errno;
		cerr << "'epoll_create1' failed [" << en << " <" << strerror(en) << ">]!" << endl;
	}

	if(to >= -1 && to <= 10000)
		timeout = to;
	else
		cerr << "Invalid timeout '" << to << "' " << "(valid values are -1 to 10000)!" << endl;

	events = (struct epoll_event *) malloc(sizeof(struct epoll_event) * maxevtcnt);
	if(events == nullptr)
		cerr << "malloc failed!" << endl;
}


/////////////////////////////////////////////////////////////////////////////////
// ~EPoller()
/////////////////////////////////////////////////////////////////////////////////
EPoller::~EPoller()
{
	if(epollfd != -1)
		Shutdown();

	free(events);
}


/////////////////////////////////////////////////////////////////////////////////
// Ready()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::Ready()
{
	if(epollfd > -1 || timeout != -2 || events == nullptr) //fix me
		return true;
	return false;
}


/////////////////////////////////////////////////////////////////////////////////
// Shutdown()
/////////////////////////////////////////////////////////////////////////////////
void EPoller::Shutdown()
{
	if(epollfd > -1)
		close(epollfd);
	epollfd = -1;
}


/////////////////////////////////////////////////////////////////////////////////
// AddFD()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::AddFD(int fd, int epoll_events, epoller_cb_t *cb)
{
	fdcnt++;
	return addmoddelfd(fd, epoll_events, cb, EPOLL_CTL_ADD);
}


/////////////////////////////////////////////////////////////////////////////////
// ModifyFD()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::ModifyFD(int fd, int epoll_events, epoller_cb_t *cb)
{
	return addmoddelfd(fd, epoll_events, cb, EPOLL_CTL_ADD);
}


/////////////////////////////////////////////////////////////////////////////////
// RemoveFD()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::RemoveFD(int fd)
{
	fdcnt--;
	return addmoddelfd(fd, 0, nullptr, EPOLL_CTL_DEL);
}


/////////////////////////////////////////////////////////////////////////////////
// addmoddelfd()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::addmoddelfd(int fd, int epoll_events, epoller_cb_t *cb, int op)
{
	struct epoll_event event;

	event.data.ptr = cb;
	event.events = epoll_events;

	if(epoll_ctl(epollfd, op, fd, &event) < 0)
	{
		typeof(errno) en = errno;
		cerr << "'epoll_ctl' failed [" << en << " <" << strerror(en) << ">]!" << endl;
		return false;
	}

	return true;
}


/////////////////////////////////////////////////////////////////////////////////
// Poll()
/////////////////////////////////////////////////////////////////////////////////
EPoller::epoller_rv EPoller::Poll()
{
	if(fdcnt == 0)
		return EPOLLER_NODATA;

	rdyfds = epoll_wait(epollfd, events, maxevtcnt, timeout);
	if(rdyfds < 0)
	{
		typeof(errno) en = errno;
		cerr << "'epoll_ctl' failed [" << en << " <" << strerror(en) << ">]!" << endl;
		return EPOLLER_ERR;
	}
	else if(rdyfds == 0)
		return EPOLLER_NODATA;
	else
		return EPOLLER_DATA;
}


/////////////////////////////////////////////////////////////////////////////////
// ProccessLoop()
/////////////////////////////////////////////////////////////////////////////////
bool EPoller::ProccessLoop()
{
	bool rv;

	if(rdyfds < 0)
		return false;

	for(int i = 0; i < rdyfds; i++)
	{
		rv = ((epoller_cb_t *) events[i].data.ptr)->funct(((epoller_cb_t *) events[i].data.ptr)->obj, events[i].events);
		if(rv == false)
			return false;
	}

	return true;
}
